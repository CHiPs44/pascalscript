(* 
    Pascal EBNF, written from http://downloads.freepascal.org/fpc/docs-pdf/ref.pdf
    EBNF syntax from ???
    Other attempt: https://github.com/rochus-keller/FreePascal/blob/master/syntax/FreePascal.ebnf
*)

letter                  =   'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' 
                        |   'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z'
                        |   'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' 
                        |   'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'
                        ;
bin_digit               =   '0' | '1' ;
oct_digit               =   bin_digit | '2'  '3' | '4' |'5' | '6' | '7' ;
dec_digit               =   oct_digit | '8' | '9' ;
hex_digit               =   dec_digit | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' ;

(*
    ' + - * / = < > [ ] . , ( ) : ^ @ { } $ # & %
    << >> ** <> >< <= >= := += -= *= /= (* \*) (. .) //
*)

identifier              =   letter | '_' , [ letter | dec_digit | '_' ]* ;

bin_digit_sequence      =   hex_digit , [ hex_digit ]* ;
oct_digit_sequence      =   oct_digit , [ oct_digit ]* ;
dec_digit_sequence      =   dec_digit , [ dec_digit ]* ;
hex_digit_sequence      =   hex_digit , [ hex_digit ]* ;
unsigned_integer        =   dec_digit_sequence 
                        |   '%' , bin_digit_sequence 
                        |   '&' , oct_digit_sequence 
                        |   '$' , hex_digit_sequence 
                        ;
sign                    =   '+' | '-' ;
scale_factor            =   'E' | 'e' , [ sign ] , dec_digit_sequence ;
unsigned_real           =   dec_digit_sequence [ '.' dec_digit_sequence ] [ scale_factor ] ;
unsigned_number         =   unsigned_real | unsigned_integer ;
signed_number           =   sign unsigned_number ;

label                   =   'LABEL' , dec_digit_sequence | identifier ;

character_string        =   quoted_string | control_string ;
quoted_string           =   "'" , [ string_character ]* , "'" ;
string_character        =   "''" | ? Any character except ' or CR ? ;
control_string          =   '#' , unsigned_integer ;

constant_declaration    =   identifier = expression ; 
(* IGNORED typed_constant_declaration =   .. *)

type_declaration        =   identifier '=' type ;
type                    =   simple_type | string_type 
                        |   structured_type | pointer_type | 
                            procedural_type | generic_type | specialized_type | type_alias ;
simple_type             =   ordinal_type | real_type | boolean_type ;
real_type               =   real_type_identifier ;
real_type_identifier    =   'REAL' | 'SINGLE' | 'DOUBLE' | 'EXTENDED' | 'COMP' | 'CURRENCY' ; 
ordinal_type            =   'INTEGER' | 'SHORTINT' | 'SMALLINT' | 'LONGINT' | 'LONGWORD' | 'INT64' | 
                            'BYTE' | 'WORD' | 'UNSIGNED' | 'QWORD' | 'BYTEBOOL' | 'WORDBOOL' | 'LONGBOOL' | 'QWORDBOOL' ;
boolean_type            =   'BOOLEAN' | 'BOOLEAN16' | 'BOOLEAN32' | 'BOOLEAN64' ;
string_type             =   'STRING' [ '[' constant_expression ']' ] ;
enumerated_type         =   '(' identifier_list_one ')' ;
identifier_list_one     =   identifier , [ ',' , identifier ]* ;
identifier_list         =   [ identifier ] , [ ',' , identifier ]* ;
(* omitted: assigned_enum_list, hint_directives, ansi strings, ... *)

expression              =   simple_expression [ relational_operator , simple_expression ] ;
relational_operator     =   '<' | '<=' | '>' | '>=' | '=' | '<>' | 'IN' | 'IS' ;

simple_expression       =   term [ additive_operator , term ] ;
additive_operator       =   '+' | '-' | 'OR' | 'XOR' ;

term                    =   factor [ multiplicative_operator , factor ] ;
multiplicative_operator =   '*' | '/' | 'DIV' | 'MOD' | 'AND' | 'SHL' | 'SHR' | 'AS' ;

factor                  =   '(' expression ')'
                        |   variable_reference
                        |   function_call
                        |   unsigned_constant
                        |   'NOT' factor
                        |   sign factor
                        |   set_constructor
                        |   value_typecast
                        |   address_factor
                        ;

variable_reference      =   identifier ;

function_call           =   function_identifier , [ actual_parameter_list ] ;
function_identifier     =   identifier ;
actual_parameter_list   =   '(' expression [ ',' expression ]* ')'

unsigned_constant       =   unsigned_number
                        |   character_string
                        |   constant identifier
                        |   'NIL'
                        ;

(* omitted: LABEL, ASM *)
statement               =   simple_statement
                        |   structured_statement
                        ;
(* omitted: GOTO, RAISE *)
simple_statement        =   assignment_statement
                        |   procedure_statement
                        ;
(* omitted: += -= *= /= *)
assignment_statement    =   ( variable_reference | function_identifier | 'RESULT' ) ':=' expression ;
(* omitted: method identifier, qualified method identifier *)
procedure_statement     =   ( procedure_identifier | variable_reference ) [ actual_parameter_list ] ;
procedure_identifier    =   identifier ;

(* omitted: WITH, EXCEPTION *)
structured_statement    =   compound_statement
                        |   conditional_statement
                        |   repetitive_statement
                        ;
compound_statement      =   'BEGIN' [ statement_list ] [ ';' ] 'END'
statement_list          =   statement [ ';' statement ]* ;

conditional_statement   =   if_statement
                        |   case_statement
                        ;
if_statement            =   'IF' expression 'THEN' statement [ 'ELSE' statement ] ;
case_statement          =   'CASE' expression 'OF'
                        |       constant [ '..' constant ] [ ',' constant [ '..' constant ] ] ':' statement
                                [ ( 'ELSE' | 'OTHERWISE' ) statement_list [ ';' ] ]
                            'END'

repetitive_statement    =   repeat_statement
                        |   while_statement
                        |   for_statement
                        ;
repeat_statement        =   'REPEAT' statement_list [ ';' ] 'UNTIL' expression ;
while_statement         =   'WHILE' expression 'DO' statement ;
for_statement           =   'FOR' control_variable ':=' expression ( 'TO' | 'DOWNTO' ) expression 'DO' statement ;
(* NB: BREAK and CONTINUE do not appear in grammar and are not reservved keywords but are usable *)


program                 =   'PROGRAM' program_header [ '(' identifier_list ')' ] ';'
                            [ uses_clause ]
                            block
                            '.'
                        ;
uses_clause             =   'USES' identifier [ 'IN' quoted_string ] [ ',' identifier [ 'IN' quoted_string ]  ]* ';' ;
block                   =   declaration_part
                            compound_statement
                        ;
(* omitted: LABEL, RESOURCESTRING, THREADVAR *)
declaration_part        =   [
                                'CONST' constant_declaration ';' [ constant_declaration ';' ]*
                                'TYPE'  type_declaration ';' [ type_declaration ';' ]*
                                'VAR'   variable_declaration ';' [ variable_declaration ';' ]*
                                [ procedure_or_function_declaration ]*
                            ]*
                        ;

(* TO BE CONTINUED... *)

