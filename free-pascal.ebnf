(* 
    Pascal EBNF, written from http://downloads.freepascal.org/fpc/docs-pdf/ref.pdf
    EBNF syntax from ???
    Other attempt: https://github.com/rochus-keller/FreePascal/blob/master/syntax/FreePascal.ebnf
*)

letter                  =   'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' 
                        |   'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z'
                        |   'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' 
                        |   'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'
                        ;
bin_digit               =   '0' | '1' ;
oct_digit               =   bin_digit | '2'  '3' | '4' |'5' | '6' | '7' ;
dec_digit               =   oct_digit | '8' | '9' ;
hex_digit               =   dec_digit | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' ;

(*
    ' + - * / = < > [ ] . , ( ) : ^ @ { } $ # & %
    << >> ** <> >< <= >= := += -= *= /= (* \*) (. .) //
*)

identifier              =   letter | '_' , [ letter | dec_digit | '_' ]* ;

bin_digit_sequence      =   hex_digit , [ hex_digit ]* ;
oct_digit_sequence      =   oct_digit , [ oct_digit ]* ;
dec_digit_sequence      =   dec_digit , [ dec_digit ]* ;
hex_digit_sequence      =   hex_digit , [ hex_digit ]* ;
unsigned_integer        =   dec_digit_sequence 
                        |   '$' , hex_digit_sequence 
                        |   '&' , oct_digit_sequence 
                        |   '%' , bin_digit_sequence 
                        ;
sign                    =   '+' | '-' ;
scale_factor            =   'E' | 'e' , [ sign ] , dec_digit_sequence ;
unsigned_real           =   dec_digit_sequence [ '.' dec_digit_sequence ] [ scale_factor ] ;
unsigned_number         =   unsigned_real | unsigned_integer ;
signed_number           =   sign unsigned_number ;

label                   =   'LABEL' , dec_digit_sequence | identifier ;

character_string        =   quoted_string | control_string ;
quoted_string           =   "'" , [ string_character ]* , "'" ;
string_character        =   "''" | ? Any character except ' or CR ? ;
control_string          =   '#' , unsigned_integer ;

constant_declaration    =   identifier = expression hintdirectives ; 
(* IGNORED typed_constant_declaration =   .. *)

type_declaration        =   identifier = type hint_directives ;
type                    =   simple_type | string_type | structured_type | pointer_type | 
                            procedural_type | generic_type | specialized_type | type_alias ;
simple_type             =   ordinal_type | real_type ;
real_type               =   real_type_identifier ;
ordinal_type            =   'INTEGER' | 'SHORTINT' | 'SMALLINT' | 'LONGINT' | 'LONGWORD' | 'INT64' | 
                            'BYTE' | 'WORD' | 'UNSIGNED' | 'QWORD' | 'BYTEBOOL' | 'WORDBOOL' | 'LONGBOOL' | 'QWORDBOOL' ;
boolean_type            =   'BOOLEAN' | 'BOOLEAN16' | 'BOOLEAN32' | 'BOOLEAN64' ;
enumerated_type         =   '(' identifier_list ')' ;
identifier_list         =   [ identifier ] , [ ',' , identifier ]* ;
(* IGNORED assigned_enum_list *)

expression              =   simple_expression [ relational_operator , simple_expression ] ;
relational_operator     =   '<' | '<=' | '>' | '>=' | '=' | '<>' | 'IN' | 'IS' ;

simple_expression       =   term [ additive_operator , term ] ;
additive_operator       =   '+' | '-' | 'OR' | 'XOR' ;

term                    =   factor [ multiplicative_operator , factor ] ;
multiplicative_operator =   '*' | '/' | 'DIV' | 'MOD' | 'AND' | 'SHL' | 'SHR' | 'AS' ;

factor                  =   '(' expression ')'
                        |   variable_reference
                        |   function_call
                        |   unsigned_constant
                        |   'NOT' factor
                        |   sign factor
                        |   set_constructor
                        |   value_typecast
                        |   address_factor
                        ;

variable_reference      =   identifier ;

function_call           =   function_identifier , [ '(' , actual_parameter_list , ')' ] ;

function_identifier     =   identifier ;
actual_parameter_list   =   expression [ ',' , expression ]*

unsigned_constant       =   unsigned_number
                        |   character_string
                        |   constant identifier
                        |   'NIL'
                        ;

(* TO BE CONTINUED... *)
