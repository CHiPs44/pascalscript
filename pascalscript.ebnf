(* PascalScript EBNF *)

(* LETTERS & DIGITS *)
uppercase_letter            =   'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' ;
lowercase_letter            =   'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' ;
letter                      =   lowercase_letter | uppercase_letter ;
digit                       =   '0' | '1' | '2' | '3' | '4' |'5' | '6' | '7' | '8' | '9' ;

(* NUMBERS *)
digit_sequence              =   digit , [ digit ]* ;
unsigned_integer            =   digit_sequence ;
sign                        =   '+' | '-' ;
scale_factor                =   'E' | 'e' , [ sign ] , digit_sequence ;
unsigned_real               =   digit_sequence [ '.' digit_sequence ] [ scale_factor ] ;

(* CHARS & STRINGS *)
control_char                =   '#' , unsigned_integer ;
quoted_char                 =   "'" , string_character , "'" ;
character_value             =   quoted_char | control_char ;
character_string            =   quoted_string | control_char ;
quoted_string               =   "'" , [ string_character ]* , "'" ;
string_character            =   "''" | ? Any character except ' or CR ? ;

(* IDENTIFIERS *)
identifier                  =   letter | '_' , [ letter | digit | '_' ]* ;
identifier_list             =   identifier , [ ',' identifier ]* ;

(* LABEL & GOTO *)
label                       =   digit_sequence | identifier ;
label_list                  =   label , [ ',' , label ]* ;
label_declaration           =   'LABEL' , label_list ;
goto_instruction            =   'GOTO' , label ;

(* TYPES *)
type_declaration            =   identifier , '=' , type ;
type                        =   simple_type | string_type | array_type ;
simple_type                 =   ordinal_type | real_type | boolean_type ;
ordinal_type                =   'INTEGER' | 'CARDINAL' ;
real_type                   =   'REAL' ;
boolean_type                =   'BOOLEAN' ;
string_type                 =   'STRING' , [ '[' unsigned_integer ']' ] ;
array_type                  =   'ARRAY' , '[' , ordinal_type , [ ',' , ordinal_type ]* , ']' , 'OF', type ;
(*                          |   'ARRAY' , 'OF' , type ; *)

constant_declaration        =   identifier , '=' , expression ;
const_block                 =   'CONST' , constant_declaration , ';' , [ constant_declaration , ';' ]* ;
var_block                   =   'VAR' , variable_declaration , ';' , [ variable_declaration , ';' ]* ;
type_block                  =   'TYPE' , type_declaration , ';' , [ type_declaration , ';' ]* ;

procedure_function_block    =   [ procedure_declaration | function_declaration ]* ;

procedure_declaration       =   'PROCEDURE' , identifier , [] , ';'
                                [ const_block ] ,
                                [ var_block ] ,
                                instruction_block , ';' ;

function_declaration        =   'FUNCTION' , identifier , [] , ';'
                                [ const_block ] ,
                                [ var_block ] ,
                                instruction_block , ';' ;

pascal_program              =   'PROGRAM' , identifier , ';' , 
                                [ const_block ] , 
                                [ type_block ] ,
                                [ var_block ] , 
                                instruction_block , '.' ;

instruction_block           =   'BEGIN' , [ instruction ]* , 'END' ;
instruction                 =   assignment
                            |   if_instruction
                            |   repeat_instruction
                            |   while_instruction
                            |   for_instruction
                            |   procedure_call ;

if_instruction                =   'IF' , expression ,
                                'THEN' , instruction | instruction_block [ '; ']
                                [ 'ELSE' , instruction | instruction_block ] ;

repeat_instruction                =   'REPEAT' , [ instruction ]* , 'UNTIL' , expression ;

while_instruction                    =   'WHILE' , expression , 'DO' , 
                                instruction | instruction_block, ';' ;

for_instruction            =   'FOR' , variable_reference , ':=' , 
                                expression , 'TO' | 'DOWNTO' , expression ,
                                instruction | instruction_block, ';' ;

assignment                  =   left_value , ':=' , right_value , ';' ;
left_value                  =   identifier ;
right_value                 =   expression ;

procedure_call              =   identifier | 'WRITE' | 'WRITELN' , 
                                [ '(' , parameters_list , ')' ] , ';' ;
parameters_list             =   parameter , [ ',' , parameter ]* ;
parameter                   =   expression ;

addition_operator           =   '+' | '-' | 'or' | 'xor' ;
multiplication_operator     =   '*' | '/' | 'div' | 'mod' | 'and' | 'shl' | 'shr' ;
relational_operator         =   '=' | '<>' | '<' | '<=' | '>' | '>=' ;

variable_reference          =   identifier ;
                            |   identifier '[' expression , [  ',' expression ]* ']' ;
constant_reference          =   identifier ;

relational_expression       =   expression , relational_operator , expression ;
expression                  =   term , { addition_operator , term  }
                            =   '(' expression ')' ;
term                        =   factor , { multiplication_operator , factor } ;
factor                      =   expression 
                            |   unsigned_integer
                            |   unsigned_real
                            |   character_value
                            |   character_string
                            |   variable_reference 
                            |   constant_identifier
                            |   'NOT' , expression 
                            |   sign , expression
                            |   function_call ; 

```
